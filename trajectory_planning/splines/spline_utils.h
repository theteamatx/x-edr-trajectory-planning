// Copyright 2023 Google LLC

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     https://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef TRAJECTORY_PLANNING_SPLINES_SPLINE_UTILS_H_
#define TRAJECTORY_PLANNING_SPLINES_SPLINE_UTILS_H_

#include <algorithm>
#include <vector>

#include "eigenmath/pose3.h"
#include "eigenmath/types.h"
#include "absl/log/log.h"

namespace trajectory_planning {
// Takes a list of points defining the corners of a piecewise linear curve
// (polyline) and computes waypoints for a 3rd order bspline.
// The spline will follow the polyline at distances farther than radius away
// from the corners.
// This function allocates.
// When using eigenmath::VectorXd as input, all the 'corner' vectors must be of
// the same size.
template <typename VecInType, typename VecOutType>
void PolyLineToBspline3Waypoints(const std::vector<VecInType>& corners,
                                 const double radius,
                                 std::vector<VecOutType>* output) {
  CHECK(output != nullptr);
  std::vector<eigenmath::VectorXd> output_vecx;
  PolyLineToBspline3Waypoints<eigenmath::VectorXd>(
      std::vector<eigenmath::VectorXd>(corners.begin(), corners.end()), radius,
      &output_vecx);
  *output = std::vector<VecOutType>(output_vecx.begin(), output_vecx.end());
}

namespace spline_utils_details {
inline constexpr double kMinWaypointSpacingFactor = 4.0;
}

// Returns the maximum (infinity norm) distance between a polyline and a third
// order spline with uniform knots and control points generated by
// PolyLineToBspline3Waypoints.
inline constexpr double PolyLineToBspline3WaypointsMaximumPathError(
    double radius, double waypoint_distance) {
  // Evaluating the 3rd order b-spline with uniform knot vector at the point
  // closest to the corner rounded via the control point conversion in
  // PolyLineToBspline3Waypoints yields:
  // point_on_spline= 1/6 * (waypoint - effective_radius) + 4/6 * waypoint
  //                + 1/6 * (waypoint-effective_radius),
  // so the maximum distance from the polyline traced by the waypoints is
  // 1/3 * (effective_radius).
  constexpr double kOneThird = 1.0 / 3.0;
  return kOneThird *
         std::min(radius, waypoint_distance /
                              spline_utils_details::kMinWaypointSpacingFactor);
}

// specialization for eigenmath::VectorXd types, this is the actual
// implementation
template <>
void PolyLineToBspline3Waypoints(
    const std::vector<eigenmath::VectorXd>& corners, const double radius,
    std::vector<eigenmath::VectorXd>* output);

// Implementation for poses.
//  Linear quaternion interpolation is defined as a linear increase of the
//  angle around a fixed axis between the quaternions at each corner.
//  Both translation and rotational radii are required, but only the most
//  conservative value (whichever results in the smallest percentage of the
//  difference between corner poses) is used.
void PolyLineToBspline3Waypoints(const std::vector<eigenmath::Pose3d>& corners,
                                 const double translation_radius,
                                 const double rotational_radius,
                                 std::vector<eigenmath::Pose3d>* output);

// Returns the corner offset used for corner rounding between waypoints at a
// distance of `delta` with a corner rounding parameter `radius`.
eigenmath::VectorXd PolyLineToBspline3WaypointsCornerOffset(
    const eigenmath::VectorXd& delta, const double radius);
}  // namespace trajectory_planning

#endif  // TRAJECTORY_PLANNING_SPLINES_SPLINE_UTILS_H_
