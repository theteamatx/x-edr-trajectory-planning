// Copyright 2023 Google LLC

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     https://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "trajectory_planning/splines/bsplineq.h"

#include <array>
#include <cmath>
#include <cstdint>
#include <limits>
#include <random>
#include <string>
#include <tuple>
#include <vector>

#include "absl/log/log.h"
#include "absl/status/status.h"
#include "absl/strings/str_format.h"
#include "eigenmath/matchers.h"
#include "eigenmath/rotation_utils.h"
#include "eigenmath/so2.h"
#include "eigenmath/so3.h"
#include "eigenmath/types.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

namespace trajectory_planning {
namespace {

using eigenmath::testing::IsApprox;
using ::testing::ElementsAreArray;
using ::testing::HasSubstr;
using Quaterniond = eigenmath::Quaterniond;
using bsplineq_details::QuatExp;
using bsplineq_details::QuatLog;
using bsplineq_details::QuatPower;
using bsplineq_details::QuatPowerDerivative;

#define ASSERT_OK(x) ASSERT_TRUE(x.ok());
#define EXPECT_OK(x) EXPECT_TRUE(x.ok());

MATCHER_P(StatusIs, s, "") { return arg.code() == s; }
MATCHER_P2(StatusIs, s, str_matcher, "") {
  return arg.code() == s &&
         testing::ExplainMatchResult(str_matcher, arg.message(),
                                     result_listener);
}

constexpr size_t kMaxNumKnots = 100;
constexpr double kEpsilon = 1e-6;

const double InsertKnotError(int degree) {
  // For degree == 1, the solution is exact.
  // For degree == 2, the approximate first-order solution is used.
  // For degree > 2 control points are computed numerically and the
  // error is significantly larger.
  if (degree <= 1) {
    return 1e-12;
  }
  if (degree == 2) {
    return 2e-2;
  }
  return 7e-2;
}

BSplineQ GetTestSpline(int degree, int max_knot) {
  CHECK_GE(degree, 0);
  CHECK_GE(max_knot, 1);
  const int knot_count = (degree + 1) * 2 + max_knot - 1;
  Eigen::ArrayXd knots(knot_count);
  knots.head(degree + 1).setConstant(0.0);
  knots.segment(degree + 1, max_knot - 1) =
      Eigen::ArrayXd::LinSpaced(max_knot - 1, 1, max_knot - 1);
  knots.tail(degree + 1).setConstant(max_knot);
  BSplineQ spline;
  CHECK_OK(spline.Init(degree, knots.size()));
  CHECK_EQ(spline.SetKnotVector(knots).code(), absl::StatusCode::kOk);

  // Initialize points.
  std::vector<Quaterniond> polygon(spline.MaxNumPoints());
  for (int i = 0; i < polygon.size(); ++i) {
    polygon[i].coeffs().setZero();
    polygon[i].coeffs()[i % 4] = 1.0;
  }
  CHECK_EQ(spline.SetControlPoints(polygon).code(), absl::StatusCode::kOk);
  return spline;
}

TEST(QuatExpAndLogTest, ResultsMatchGoldenValues) {
  // Golden values generated with Mathematica.
  // Inputs generated from:
  // `Table[eigenmath::Quaterniond(RandomReal[{-5, 5}], RandomReal[{-5, 5}],
  // RandomReal[{-5, 5}], RandomReal[{-5, 5}]], {i, 1, 15}]`.
  // Output generated by calling Exp[] on the input data.
  constexpr int kGoldenDataCount = 15;
  const eigenmath::Quaterniond golden_input[kGoldenDataCount] = {
      eigenmath::Quaterniond(4.303205432487065, -4.463768474906464,
                             2.771415047773054, 3.462743420543134),
      eigenmath::Quaterniond(3.718019751858115, -0.3146547699253155,
                             3.054467467394105, 4.230413914633292),
      eigenmath::Quaterniond(0.9880734813254293, -4.881095169908816,
                             -1.636174015184171, 0.4569182173694912),
      eigenmath::Quaterniond(2.393126143245684, 4.936087432764154,
                             -0.7286435432774354, 1.398258270648913),
      eigenmath::Quaterniond(-4.490880012959778, -1.237872356144401,
                             4.954204031597826, 4.307264094591666),
      eigenmath::Quaterniond(0.9261642930425182, -0.187800423995137,
                             1.026107686324131, 2.705334212316924),
      eigenmath::Quaterniond(3.606217765470561, -0.1727877354842367,
                             0.5905684706369758, 2.845941590438777),
      eigenmath::Quaterniond(0.2458943106706979, 1.648620615741692,
                             -0.9351166547491481, -3.095681574813398),
      eigenmath::Quaterniond(-3.990575657981117, 3.588133655974055,
                             -4.968104091082521, 1.264935532568053),
      eigenmath::Quaterniond(-2.980370109687698, -0.2878915237310906,
                             3.26742463113359, -4.687850404638624),
      eigenmath::Quaterniond(2.176604800183121, -3.545699895761194,
                             2.473327081822788, -4.53473425450883),
      eigenmath::Quaterniond(-3.470775775607898, -0.5603791291261224,
                             -1.540934904282587, -0.5909379242488733),
      eigenmath::Quaterniond(2.681194483053609, -2.219682988427108,
                             -3.962655288856594, 2.271259973348439),
      eigenmath::Quaterniond(-0.6497522043314348, -0.1136494572801716,
                             2.340185806900713, -3.174207267168153),
      eigenmath::Quaterniond(0.654521316825857, 0.1141032444312096,
                             0.08728652759662481, -1.908560169741424)};

  const eigenmath::Quaterniond golden_exp_output[kGoldenDataCount] = {
      eigenmath::Quaterniond(73.93314968184431, -0.4927253819344566,
                             0.3059178686326228, 0.3822289583385918),
      eigenmath::Quaterniond(20.2825239705365, 2.15746299010544,
                             -20.94327226295668, -29.00627076403362),
      eigenmath::Quaterniond(1.182525233329912, 2.277742065672333,
                             0.7635135664061653, -0.2132189207640357),
      eigenmath::Quaterniond(4.952255524791761, -9.30056714028261,
                             1.372908865147527, -2.634595740607302),
      eigenmath::Quaterniond(0.01033752190054933, -0.0008037918177509189,
                             0.003216929955904452, 0.002796850272114192),
      eigenmath::Quaterniond(-2.451168275381038, -0.03920719746851603,
                             0.2142210641798876, 0.5647941065531807),
      eigenmath::Quaterniond(-35.8576483263963, -0.4979835946208021,
                             1.702050258679042, 8.202157516074617),
      eigenmath::Quaterniond(-1.129357247916673, -0.2724330764657741,
                             0.154527187562241, 0.511558600645915),
      eigenmath::Quaterniond(0.01848298867101701, -0.0002718428739319226,
                             0.0003763916909461358, -0.00009583358466577507),
      eigenmath::Quaterniond(0.04297145229381205, 0.001360874061898228,
                             -0.01544523913760815, 0.0221596451991784),
      eigenmath::Quaterniond(8.814901624403754, 0.08956530615941652,
                             -0.06247688857724865, 0.11454857258005),
      eigenmath::Quaterniond(-0.005324933306941596, -0.00984930820793604,
                             -0.02708370460604672, -0.01038641420632772),
      eigenmath::Quaterniond(5.223604950401545, 5.960400044333744,
                             10.64071350842621, -6.098897057111925),
      eigenmath::Quaterniond(-0.3624314655136727, 0.01082879325008322,
                             -0.2229785242813324, 0.3024460921475303),
      eigenmath::Quaterniond(-0.6474376631185546, 0.1080265732506104,
                             0.0826380048543924, -1.806918076760456)};

  for (int i = 0; i < kGoldenDataCount; ++i) {
    SCOPED_TRACE(absl::StrFormat("Golden data %d / %d.", i, kGoldenDataCount));
    const eigenmath::Quaterniond quat_exp = QuatExp(golden_input[i]);
    EXPECT_THAT(quat_exp, IsApprox(golden_exp_output[i]))
        << " QuatExp doesn't match golden output for input= "
        << golden_input[i];

    // Expect Exp(Log(q)) == q for the input data (there is nothing special
    // about that data set).
    const eigenmath::Quaterniond log_input = QuatLog(golden_input[i]);
    const eigenmath::Quaterniond exp_log_input = QuatExp(log_input);
    EXPECT_THAT(exp_log_input, IsApprox(golden_input[i]))
        << " QuatLog(QuatExp(input)) doesn't recover the input for input= "
        << golden_input[i];

    // Log(q) is multivalued, so Log(golden_exp_output[i]) doesn't have to match
    // golden_input[i]. However, Log(Exp(q)) should be q for normalized inputs.
    const eigenmath::Quaterniond normalized_input =
        golden_input[i].normalized();
    const eigenmath::Quaterniond exp_normalized_input =
        QuatExp(normalized_input);
    const eigenmath::Quaterniond log_exp_normalized_input =
        QuatLog(exp_normalized_input);
    EXPECT_THAT(log_exp_normalized_input, IsApprox(normalized_input))
        << " QuatExp(QuatLog(input.normalized())) doesn't recover the input "
           "for input= "
        << golden_input[i] << " normalized_input= " << normalized_input;
  }
}

TEST(BSplineQTest, ValidNKnotsReturnsTrue) {
  constexpr size_t kDegree = 3;
  BSplineQ spline;
  ASSERT_OK(spline.Init(kDegree, kMaxNumKnots));
}

TEST(BSplineQTest, TooFewKnotsReturnsFalse) {
  constexpr size_t kDegree = 3;
  BSplineQ spline;
  EXPECT_THAT(spline.Init(kDegree, 1), StatusIs(absl::StatusCode::kOutOfRange));
}

TEST(BSplineQTest, TooManyKnotsReturnsFalse) {
  constexpr size_t kDegree = 3;
  BSplineQ spline;
  EXPECT_OK(spline.Init(kDegree, 1e5));
}

TEST(BSplineQTest, SetControlPoints) {
  constexpr size_t kDegree = 3;
  constexpr std::array<double, 12> kKnots = {
      {0, 0, 0, 0, 1, 2, 3, 4, 5, 5, 5, 5}};
  BSplineQ spline;
  ASSERT_OK(spline.Init(kDegree, kKnots.size()));

  std::vector<Quaterniond> polygon(spline.MaxNumPoints());
  std::vector<Quaterniond> polygon_s(spline.MaxNumPoints() - 1);
  std::vector<Quaterniond> polygon_l(spline.MaxNumPoints() + 1);

  for (int i = 0; i < polygon.size(); ++i) {
    polygon[i].coeffs().setZero();
    polygon[i].coeffs()(i % 4) = 1.0;
  }

  ASSERT_EQ(spline.SetKnotVector(kKnots).code(), absl::StatusCode::kOk);
  ASSERT_EQ(spline.SetControlPoints(polygon).code(), absl::StatusCode::kOk);
  const auto control_points = spline.GetControlPoints();
  ASSERT_EQ(spline.SetControlPoints(polygon_s).code(),
            absl::StatusCode::kInvalidArgument);
  ASSERT_EQ(spline.SetControlPoints(polygon_l).code(),
            absl::StatusCode::kOutOfRange);

  EXPECT_THAT(control_points, ElementsAreArray(polygon));
}

TEST(BSplineQTest, EvalCurveDoesNotAllocate) {
  constexpr size_t kDegree = 3;
  constexpr std::array<double, 12> kKnots = {
      {0, 0, 0, 0, 1, 2, 3, 4, 5, 5, 5, 5}};
  BSplineQ spline;
  ASSERT_OK(spline.Init(kDegree, kKnots.size()));
  std::vector<Quaterniond> polygon(spline.MaxNumPoints());

  ASSERT_EQ(spline.SetKnotVector(kKnots).code(), absl::StatusCode::kOk);

  // Initialize points.
  for (int i = 0; i < polygon.size(); ++i) {
    polygon[i].coeffs().setZero();
    polygon[i].coeffs()[i % 4] = 1.0;
  }
  ASSERT_EQ(spline.SetControlPoints(polygon).code(), absl::StatusCode::kOk);

  for (double u = kKnots[0]; u <= kKnots[kKnots.size() - 1]; u += 0.01) {
    Quaterniond quat = Quaterniond::Identity();
    ASSERT_EQ(spline.EvalCurve(u, quat).code(), absl::StatusCode::kOk);
  }
}

TEST(BSplineQTest, CurveEvaluationWorksWithoutSettingControlPoints) {
  constexpr size_t kDegree = 3;
  constexpr std::array<double, 12> kKnots = {
      {0, 0, 0, 0, 1, 2, 3, 4, 5, 5, 5, 5}};
  BSplineQ spline;
  ASSERT_OK(spline.Init(kDegree, kKnots.size()));

  ASSERT_EQ(spline.SetKnotVector(kKnots).code(), absl::StatusCode::kOk);

  for (double u = kKnots[0]; u <= kKnots[kKnots.size() - 1]; u += 0.01) {
    Quaterniond quat(1, 2, 3, 4);
    ASSERT_OK(spline.EvalCurve(u, quat));
    EXPECT_THAT(quat, IsApprox(Quaterniond(1, 0, 0, 0)));
  }
}

TEST(BSplineQTest, EvalCurveParameterRange) {
  // umin,umax matching knot vector.
  constexpr size_t kDegree = 3;
  constexpr std::array<double, 10> kNots = {0, 0, 0, 0, 1, 2, 3, 3, 3, 3};
  // Set points function.
  BSplineQ spline;
  ASSERT_OK(spline.Init(kDegree, kNots.size()));
  std::vector<Quaterniond> points(spline.MaxNumPoints());

  for (auto& point : points) {
    point = Quaterniond(1, 0, 0, 0);
  }
  Quaterniond quat = Quaterniond::Identity();

  ASSERT_EQ(spline.SetKnotVector(kNots).code(), absl::StatusCode::kOk);
  ASSERT_EQ(spline.SetControlPoints(points).code(), absl::StatusCode::kOk);

  ASSERT_EQ(spline.EvalCurve(0.0, quat).code(), absl::StatusCode::kOk);
  ASSERT_EQ(spline.EvalCurve(0.5, quat).code(), absl::StatusCode::kOk);
  ASSERT_EQ(spline.EvalCurve(3.0, quat).code(), absl::StatusCode::kOk);
  ASSERT_EQ(spline.EvalCurve(-0.1, quat).code(), absl::StatusCode::kOutOfRange);
  ASSERT_EQ(spline.EvalCurve(3.1, quat).code(), absl::StatusCode::kOutOfRange);
}

// A linear spline should be the same as piecewise slerp.
TEST(BSplineQTest, LinearCaseWorks) {
  constexpr int kDegree = 1;
  // Constructor arguments are w, x, y, z.
  const std::vector<Quaterniond> points = {
      Quaterniond(1, 0, 0, 0),
      Quaterniond(0, 1, 0, 0),
      Quaterniond(0, 0, 1, 0),
      Quaterniond(0, 0, 0, 1),
      Quaterniond(M_SQRT1_2, M_SQRT1_2, 0, 0),
      Quaterniond(M_SQRT1_2, 0, M_SQRT1_2, 0),
      Quaterniond(M_SQRT1_2, 0, 0, M_SQRT1_2)};
  std::vector<double> knots;
  knots.reserve(BSplineQ::NumKnots(points.size(), kDegree));
  ASSERT_OK(BSplineQ::MakeUniformKnotVector(points.size(), &knots, kDegree));

  BSplineQ spline;
  ASSERT_OK(spline.Init(kDegree, knots.size()));
  ASSERT_OK(spline.SetKnotVector(knots));
  ASSERT_OK(spline.SetControlPoints(points));

  for (int i = kDegree; i < knots.size() - kDegree; ++i) {
    // Control points should be interpolated.
    Quaterniond interpolated_quat;
    ASSERT_OK(spline.EvalCurve(knots[i], interpolated_quat));
    EXPECT_THAT(interpolated_quat, IsApprox(points[i - 1]));
    // Interpolation should match slerp.
    if (i < points.size() - 2) {
      for (double t = 0.1; t < 1; t += 0.2) {
        const double u = knots[i] + t * (knots[i + 1] - knots[i]);
        ASSERT_OK(spline.EvalCurve(u, interpolated_quat));
        const Quaterniond slerp_quat = points[i - 1].slerp(t, points[i]);
        EXPECT_THAT(interpolated_quat, IsApprox(slerp_quat));
      }
    }
  }
}

TEST(BSplineQTest, QuatPowerDerivativeWorks) {
  constexpr double kDeltaFD = 1e-5;
  auto quat_deriv_fd = [](const eigenmath::Quaterniond quat,
                          const double power) -> eigenmath::Quaterniond {
    const eigenmath::Quaterniond left = QuatPower(quat, power - kDeltaFD);
    const eigenmath::Quaterniond right = QuatPower(quat, power + kDeltaFD);
    eigenmath::Quaterniond result;
    result.coeffs() = (right.coeffs() - left.coeffs()) / (2.0 * kDeltaFD);
    return result;
  };
  constexpr int kAngleSteps = 10;
  for (int alpha_i = 0; alpha_i < kAngleSteps; ++alpha_i) {
    const double alpha = -M_PI_2 + (M_PI / kAngleSteps - 1) * alpha_i;
    for (int beta_i = 0; beta_i < kAngleSteps; ++beta_i) {
      const double beta = -M_PI_2 + (M_PI / kAngleSteps - 1) * beta_i;
      for (int gamma_i = 0; gamma_i < kAngleSteps; ++gamma_i) {
        const double gamma = -M_PI_2 + (M_PI / kAngleSteps - 1) * gamma_i;
        for (double power = -10; power < 10; power += M_PI / M_E) {
          const eigenmath::Quaterniond quat =
              eigenmath::QuaternionFromRPY(alpha, beta, gamma);
          const eigenmath::Quaterniond diff_quat =
              QuatPowerDerivative(quat, power);
          const eigenmath::Quaterniond diff_quat_numerical =
              quat_deriv_fd(quat, power);
          EXPECT_THAT(diff_quat.coeffs(),
                      IsApprox(diff_quat_numerical.coeffs(), kDeltaFD));
        }
      }
    }
  }
}

TEST(BSplineQTest, CumulativeBasisFunctionDerivativesWork) {
  constexpr int kMaxDegreeToTest = 5;
  for (int degree = 1; degree <= kMaxDegreeToTest; ++degree) {
    SCOPED_TRACE(absl::StrFormat("degree= %d", degree));
    constexpr int kMaxKnot = 5;
    BSplineQ spline = GetTestSpline(degree, kMaxKnot);
    const auto knots = spline.GetKnotVector();
    // kDeltaU is chosen to avoid knots in the loop below, because
    // finite differences will be incorrect if left and right side evaluation
    // are in different knot spans.
    constexpr double kDeltaU = 0.01333;
    constexpr double kDeltaFD = 1e-4;
    for (double u = knots[0] + kDeltaU; u < knots[knots.size() - 1] - kDeltaU;
         u += kDeltaU) {
      spline.UpdateCumulativeBasisAndDerivative(u - kDeltaFD);
      const Eigen::ArrayXd left_cumulative_basis = spline.GetCumulativeBasis();
      spline.UpdateCumulativeBasisAndDerivative(u + kDeltaFD);
      const Eigen::ArrayXd right_cumulative_basis = spline.GetCumulativeBasis();
      const Eigen::ArrayXd numerical_cumulative_basis_derivative =
          (right_cumulative_basis - left_cumulative_basis) / (2.0 * kDeltaFD);
      spline.UpdateCumulativeBasisAndDerivative(u);
      const Eigen::ArrayXd cumulative_basis_derivative =
          spline.GetCumulativeBasisDerivative();
      EXPECT_THAT(cumulative_basis_derivative,
                  IsApprox(numerical_cumulative_basis_derivative,
                           10.0 * kDeltaFD * kDeltaFD));
    }
  }
}

TEST(BSplineQTest, DerivativesWork) {
  constexpr int kMaxDegreeToTest = 5;
  constexpr int kMaxKnot = 5;

  for (int degree = 1; degree <= kMaxDegreeToTest; ++degree) {
    SCOPED_TRACE(absl::StrFormat("degree= %d", degree));
    BSplineQ spline = GetTestSpline(degree, kMaxKnot);
    const auto knots = spline.GetKnotVector();
    // kDeltaU is chosen to avoid knots in the loop below, because
    // finite differences will be incorrect if left and right side evaluation
    // are in different knot spans.
    constexpr double kDeltaU = 0.01333;
    constexpr double kDeltaFD = 1e-4;
    for (double u = knots[0] + kDeltaU; u < knots[knots.size() - 1] - kDeltaU;
         u += kDeltaU) {
      Quaterniond left = Quaterniond::Identity();
      Quaterniond right = Quaterniond::Identity();
      Quaterniond value = Quaterniond::Identity();
      Quaterniond derivative = Quaterniond::Identity();
      ASSERT_OK(spline.EvalCurveAndDerivative(u, value, derivative));

      ASSERT_OK(spline.EvalCurve(u - kDeltaFD, left));
      ASSERT_OK(spline.EvalCurve(u + kDeltaFD, right));

      Quaterniond numerical_derivative;
      numerical_derivative.coeffs() =
          (right.coeffs() - left.coeffs()) / (2.0 * kDeltaFD);
      EXPECT_THAT(numerical_derivative.coeffs(),
                  IsApprox(derivative.coeffs(), kDeltaFD));
    }
  }
}

TEST(BSplineQTest, InsertKnotFailsForInvalidInput) {
  BSplineQ spline;
  constexpr int kDegree = 2;
  constexpr int kMinPoints = BSplineBase::MinNumPoints(kDegree);
  constexpr int kMinCapacity = BSplineBase::NumKnots(kMinPoints, kDegree);
  ASSERT_OK(spline.Init(kDegree, kMinCapacity));

  EXPECT_THAT(
      spline.InsertKnotAndUpdateControlPoints(0.5, 10),
      StatusIs(absl::StatusCode::kInvalidArgument, HasSubstr("multiplicity")));

  EXPECT_THAT(spline.InsertKnotAndUpdateControlPoints(0.5, 1),
              StatusIs(absl::StatusCode::kFailedPrecondition,
                       HasSubstr("Set initial knot vector first")));

  ASSERT_OK(spline.SetUniformKnotVector(kMinCapacity));

  EXPECT_THAT(spline.InsertKnotAndUpdateControlPoints(0.5, 1),
              StatusIs(absl::StatusCode::kFailedPrecondition,
                       HasSubstr("capacity too small")));

  // Resize and set a new knot vector.
  ASSERT_OK(spline.Init(kDegree, kMinCapacity + 1));
  ASSERT_OK(spline.SetUniformKnotVector(kMinCapacity));
  EXPECT_THAT(
      spline.InsertKnotAndUpdateControlPoints(-0.5, 1),
      StatusIs(absl::StatusCode::kInvalidArgument, HasSubstr("not in range")));
  EXPECT_THAT(
      spline.InsertKnotAndUpdateControlPoints(1.5, 1),
      StatusIs(absl::StatusCode::kInvalidArgument, HasSubstr("not in range")));
  EXPECT_THAT(
      spline.InsertKnotAndUpdateControlPoints(0.5, 10),
      StatusIs(absl::StatusCode::kInvalidArgument, HasSubstr("multiplicity")));
}

TEST(BSplineQTest, InsertKnotWorksForValidInput) {
  // Loops over a range of degrees, knot multiplicities and knot values and
  // verifies that the spline curve position values are unchanged after knot
  // insertion.
  BSplineQ spline_ref;
  const std::vector<Quaterniond> points = {
      Quaterniond(1, 0, 0, 0), Quaterniond(M_SQRT1_2, M_SQRT1_2, 0, 0),
      Quaterniond(0, 1, 0, 0), Quaterniond(0, M_SQRT1_2, M_SQRT1_2, 0),
      Quaterniond(0, 0, 1, 0), Quaterniond(0, 0, M_SQRT1_2, M_SQRT1_2),
      Quaterniond(0, 0, 0, 1)};

  for (int degree = 1; degree <= 3; ++degree) {
    SCOPED_TRACE(absl::StrCat("degree= ", degree));
    for (int knot_multiplicity = 1; knot_multiplicity <= degree;
         ++knot_multiplicity) {
      SCOPED_TRACE(absl::StrCat("knot_multiplicity= ", knot_multiplicity));
      const int capacity =
          BSplineBase::NumKnots(points.size(), degree) + knot_multiplicity;
      ASSERT_OK(spline_ref.Init(degree, capacity));
      ASSERT_OK(spline_ref.SetUniformKnotVector(
          BSplineBase::NumKnots(points.size(), degree)));
      ASSERT_OK(spline_ref.SetControlPoints(points));

      // A few knot values that fall in different knot spans.
      const int knot_count = spline_ref.GetKnotVector().size();
      const std::vector<double> knots_to_insert = {
          0.66 * spline_ref.GetKnotVector()[0] +
              0.34 * spline_ref.GetKnotVector()[degree + 1],
          0.66 * spline_ref.GetKnotVector().front() +
              0.34 * spline_ref.GetKnotVector().back(),
          0.34 * spline_ref.GetKnotVector()[knot_count - degree - 2] +
              0.66 * spline_ref.GetKnotVector().back(),
          0.3333};
      for (int k = 0; k < knots_to_insert.size(); ++k) {
        const double the_knot = knots_to_insert[k];
        SCOPED_TRACE(absl::StrCat("the_knot= ", the_knot));
        BSplineQ spline_with_extra_knots = spline_ref;
        const std::string log_prefix =
            absl::StrCat("D", degree, "M", knot_multiplicity, "K", k);
        // Log old and new control points, as well as spline curve samples
        // for debugging and plotting.
        for (const auto& point : spline_ref.GetControlPoints()) {
          LOG(INFO) << log_prefix
                    << "-OLD_CONTROL_POINTS: " << point.coeffs().transpose()
                    << "\n";
        }
        // Insert knot(s) by solving system of equations.
        EXPECT_OK(spline_with_extra_knots.InsertKnotAndUpdateControlPoints(
            the_knot, knot_multiplicity));

        for (const auto& point : spline_with_extra_knots.GetControlPoints()) {
          LOG(INFO) << log_prefix
                    << "-NEW_CONTROL_POINTS: " << point.coeffs().transpose()
                    << "\n";
        }

        for (double u = spline_ref.GetKnotVector().front();
             u <= spline_ref.GetKnotVector().back(); u += 0.001) {
          Quaterniond curve_reference;
          ASSERT_OK(spline_ref.EvalCurve(u, curve_reference));
          Quaterniond curve_value;
          ASSERT_OK(spline_with_extra_knots.EvalCurve(u, curve_value));
          LOG(INFO) << log_prefix << "-CURVE_VALUE: " << u << " "
                    << curve_value.coeffs().transpose() << "\n";
          LOG(INFO) << log_prefix << "-REFERENCE_VALUE: " << u << " "
                    << curve_reference.coeffs().transpose() << "\n";
          LOG(INFO)
              << log_prefix << "-CURVE_ERROR: " << u << " "
              << (curve_value.inverse() * curve_reference).coeffs().transpose();
          EXPECT_TRUE(eigenmath::SO3d(curve_value)
                          .isApprox(eigenmath::SO3d(curve_reference),
                                    InsertKnotError(degree)))
              << "InsertKnotAndUpdateControlPoints modified curve values "
              << " expected: " << curve_reference << " actual: " << curve_value
              << " rotation error: "
              << (eigenmath::SO3d(curve_value).inverse() *
                  eigenmath::SO3d(curve_reference))
              << " norm: "
              << (eigenmath::SO3d(curve_value).inverse() *
                  eigenmath::SO3d(curve_reference))
                     .norm();
        }
      }
    }
  }
}

TEST(BSplineQTest, TruncateSplineAtIsNoopForLargeParameter) {
  BSplineQ spline_ref;
  const std::vector<Quaterniond> points = {
      Quaterniond(1, 0, 0, 0), Quaterniond(M_SQRT1_2, M_SQRT1_2, 0, 0),
      Quaterniond(0, 1, 0, 0), Quaterniond(0, M_SQRT1_2, M_SQRT1_2, 0),
      Quaterniond(0, 0, 1, 0), Quaterniond(0, 0, M_SQRT1_2, M_SQRT1_2),
      Quaterniond(0, 0, 0, 1)};
  constexpr int kDegree = 3;
  constexpr int kCapacity = 20;  // Large enough.

  ASSERT_OK(spline_ref.Init(kDegree, kCapacity));
  ASSERT_OK(spline_ref.SetUniformKnotVector(
      BSplineBase::NumKnots(points.size(), kDegree)));
  ASSERT_OK(spline_ref.SetControlPoints(points));

  BSplineQ spline = spline_ref;

  ASSERT_OK(spline.TruncateSplineAt(spline.GetKnotVector().back() + 1));
  EXPECT_THAT(spline.GetKnotVector(),
              ElementsAreArray(spline_ref.GetKnotVector()));
  EXPECT_THAT(spline.GetControlPoints(), ElementsAreArray(points));

  ASSERT_OK(spline.TruncateSplineAt(spline.GetKnotVector().back()));
  EXPECT_THAT(spline.GetKnotVector(),
              ElementsAreArray(spline_ref.GetKnotVector()));
  EXPECT_THAT(spline.GetControlPoints(), ElementsAreArray(points));
}

TEST(BSplineQTest, TruncateSplineAtClearsCurveForSmallParameter) {
  BSplineQ spline_ref;
  const std::vector<Quaterniond> points = {
      Quaterniond(1, 0, 0, 0), Quaterniond(M_SQRT1_2, M_SQRT1_2, 0, 0),
      Quaterniond(0, 1, 0, 0), Quaterniond(0, M_SQRT1_2, M_SQRT1_2, 0),
      Quaterniond(0, 0, 1, 0), Quaterniond(0, 0, M_SQRT1_2, M_SQRT1_2),
      Quaterniond(0, 0, 0, 1)};
  constexpr int kDegree = 3;
  constexpr int kCapacity = 20;  // Large enough.

  ASSERT_OK(spline_ref.Init(kDegree, kCapacity));
  ASSERT_OK(spline_ref.SetUniformKnotVector(
      BSplineBase::NumKnots(points.size(), kDegree)));
  ASSERT_OK(spline_ref.SetControlPoints(points));

  BSplineQ spline = spline_ref;

  Quaterniond value;
  // Trunctating exactly at u_min should leave an empty curve.
  ASSERT_OK(spline.TruncateSplineAt(spline.GetKnotVector().front()));
  EXPECT_TRUE(spline.GetKnotVector().empty());
  EXPECT_TRUE(spline.GetControlPoints().empty());
  EXPECT_THAT(spline.EvalCurve(0.0, value),
              StatusIs(absl::StatusCode::kOutOfRange));

  // Truncating before u_min should leave an empty curve.
  spline = spline_ref;
  ASSERT_OK(spline.TruncateSplineAt(spline.GetKnotVector().front() - 1.0));
  EXPECT_TRUE(spline.GetKnotVector().empty());
  EXPECT_TRUE(spline.GetControlPoints().empty());
  EXPECT_THAT(spline.EvalCurve(0.0, value),
              StatusIs(absl::StatusCode::kOutOfRange));
}

TEST(BSplineQTest, TruncateSplineAtWorksForParametersInValidRange) {
  BSplineQ spline_ref;
  const std::vector<Quaterniond> points = {
      Quaterniond(1, 0, 0, 0), Quaterniond(M_SQRT1_2, M_SQRT1_2, 0, 0),
      Quaterniond(0, 1, 0, 0), Quaterniond(0, M_SQRT1_2, M_SQRT1_2, 0),
      Quaterniond(0, 0, 1, 0), Quaterniond(0, 0, M_SQRT1_2, M_SQRT1_2),
      Quaterniond(0, 0, 0, 1)};
  constexpr int kDegree = 2;
  constexpr int kCapacity = 20;  // Large enough.

  ASSERT_OK(spline_ref.Init(kDegree, kCapacity));
  ASSERT_OK(spline_ref.SetUniformKnotVector(
      BSplineBase::NumKnots(points.size(), kDegree)));
  ASSERT_OK(spline_ref.SetControlPoints(points));

  // Log old and new control points, as well as spline curve samples for
  // debugging and plotting.
  for (const auto& point : spline_ref.GetControlPoints()) {
    LOG(INFO) << "OLD_CONTROL_POINTS: " << point.coeffs().transpose() << "\n";
  }
  // Verify that truncation works for values in (umin, umax)
  for (double knot_end_value : {0.01, 0.1, 0.3333, 0.6, 0.9, 0.999}) {
    // The acceptable error is set to a large value for degree > 2, as knot
    // insertion is done numerically in that case.
    SCOPED_TRACE(absl::StrCat("knot_end_value= ", knot_end_value));
    const std::string log_prefix = absl::StrCat("E", knot_end_value);
    BSplineQ spline = spline_ref;
    Quaterniond expected_position_at_end;
    ASSERT_OK(spline.EvalCurve(knot_end_value, expected_position_at_end));
    ASSERT_OK(spline.TruncateSplineAt(knot_end_value));

    EXPECT_THAT(spline.GetControlPoints().back(),
                IsApprox(expected_position_at_end, InsertKnotError(kDegree)));
    EXPECT_DOUBLE_EQ(spline.GetKnotVector().back(), knot_end_value);

    for (const auto& point : spline.GetControlPoints()) {
      LOG(INFO) << "NEW_CONTROL_POINTS: " << point.coeffs().transpose() << "\n";
    }

    for (double u = spline.GetKnotVector().front();
         u <= spline.GetKnotVector().back(); u += 0.001) {
      Quaterniond curve_reference;
      ASSERT_OK(spline_ref.EvalCurve(u, curve_reference));
      Quaterniond curve_value;
      ASSERT_OK(spline.EvalCurve(u, curve_value));
      EXPECT_THAT(curve_value,
                  IsApprox(curve_reference, InsertKnotError(kDegree)))
          << " For u= " << u << " knot_end_value = " << knot_end_value
          << " diff= "
          << (curve_value.coeffs() - curve_reference.coeffs()).transpose();
      LOG(INFO) << log_prefix << "-CURVE_VALUE: " << u << " "
                << curve_value.coeffs().transpose() << "\n";
      LOG(INFO) << log_prefix << "-REFERENCE_VALUE: " << u << " "
                << curve_reference.coeffs().transpose() << "\n";
    }
  }
}

TEST(BSplineQTest, ExtendWithControlPointsFailsForInvalidInput) {
  BSplineQ spline;
  const std::vector<Quaterniond> points = {
      Quaterniond::Identity(), Quaterniond::Identity(), Quaterniond::Identity(),
      Quaterniond::Identity()};

  // Expect that unimplemented cases are detected.
  ASSERT_OK(spline.Init(3, 100));
  ASSERT_OK(
      spline.SetUniformKnotVector(BSplineBase::NumKnots(points.size(), 3)));
  ASSERT_OK(spline.SetControlPoints(points));

  EXPECT_THAT(
      spline.ExtendWithControlPoints(points),
      StatusIs(absl::StatusCode::kUnimplemented, HasSubstr("2rd order")));

  // Expect that preconditions are checked.
  ASSERT_OK(spline.Init(2, 10));
  ASSERT_OK(
      spline.SetUniformKnotVector(BSplineBase::NumKnots(points.size(), 2)));
  ASSERT_OK(spline.SetControlPoints(points));

  EXPECT_THAT(
      spline.ExtendWithControlPoints(absl::MakeConstSpan(points.data(), 1)),
      StatusIs(absl::StatusCode::kUnimplemented, HasSubstr(">= 2")));

  EXPECT_THAT(
      spline.ExtendWithControlPoints(points),
      StatusIs(absl::StatusCode::kFailedPrecondition, HasSubstr("capacity")));
}

TEST(BSplineQTest, ExtendWithControlPointsWorks) {
  BSplineQ spline_ref;
  constexpr int kDegree = 2;
  constexpr int kCapacity = 50;  // Large enough.
  const std::vector<Quaterniond> points = {
      Quaterniond(1, 0, 0, 0),  Quaterniond(M_SQRT1_2, M_SQRT1_2, 0, 0),
      Quaterniond(0, 1, 0, 0),  Quaterniond(0, M_SQRT1_2, M_SQRT1_2, 0),
      Quaterniond(0, 0, -1, 0), Quaterniond(0, 0, M_SQRT1_2, M_SQRT1_2)};
  const std::vector<Quaterniond> extra_points = {
      Quaterniond(0, 0, 0, 1), Quaterniond(0, 0, M_SQRT1_2, M_SQRT1_2),
      Quaterniond(0, 0, 1, 0), Quaterniond(0, M_SQRT1_2, M_SQRT1_2, 0),
      Quaterniond(0, 1, 0, 0), Quaterniond(M_SQRT1_2, M_SQRT1_2, 0, 0)};

  ASSERT_OK(spline_ref.Init(kDegree, kCapacity));
  ASSERT_OK(spline_ref.SetUniformKnotVector(
      BSplineBase::NumKnots(points.size(), kDegree)));
  ASSERT_OK(spline_ref.SetControlPoints(points));

  for (double u = spline_ref.GetKnotVector().front();
       u <= spline_ref.GetKnotVector().back(); u += 0.01) {
    Quaterniond curve_value;
    ASSERT_OK(spline_ref.EvalCurve(u, curve_value));
    LOG(INFO) << "REF_CURVE: " << u << " " << curve_value.coeffs().transpose()
              << " norm: " << curve_value.coeffs().norm();
  }
  for (const auto& point : spline_ref.GetControlPoints()) {
    LOG(INFO) << "REF_CONTROL_POINTS: " << point.coeffs().transpose()
              << " norm: " << point.coeffs().norm();
  }

  // Extend the curve with a different number of extra control points
  // and expect the original section to be unchanged, while the new section
  // should connect smoothly.
  for (int extra_point_count = 2; extra_point_count < extra_points.size();
       ++extra_point_count) {
    SCOPED_TRACE(absl::StrCat("extra_point_count= ", extra_point_count));
    BSplineQ spline = spline_ref;

    ASSERT_OK(spline.ExtendWithControlPoints(
        absl::MakeConstSpan(extra_points.data(), extra_point_count)));

    const std::string log_prefix = absl::StrCat("P", extra_point_count);
    for (const auto& point : spline.GetControlPoints()) {
      LOG(INFO) << log_prefix
                << "-EXTENDED_CONTROL_POINTS: " << point.coeffs().transpose();
    }
    Quaterniond curve_value, curve_derivative;
    Quaterniond ref_curve_value, ref_curve_derivative;
    for (double u = spline.GetKnotVector().front();
         u <= spline.GetKnotVector().back(); u += 0.01) {
      ASSERT_OK(
          spline.EvalCurveAndDerivative(u, curve_value, curve_derivative));

      if (u < spline_ref.GetKnotVector().back()) {
        ASSERT_OK(spline_ref.EvalCurveAndDerivative(u, ref_curve_value,
                                                    ref_curve_derivative));
        EXPECT_THAT(curve_value, IsApprox(ref_curve_value, kEpsilon));
        EXPECT_THAT(curve_derivative, IsApprox(ref_curve_derivative, kEpsilon));
      }
      LOG(INFO) << log_prefix << "-EXTENDED_CURVE: " << u << " pos "
                << curve_value.coeffs().transpose() << " vel "
                << curve_derivative.coeffs().transpose() << "\n";
    }
    // Last control point rotation should be interpolated (but it's OK if the
    // quaternion representation happens to be different).
    ASSERT_OK(spline.EvalCurve(spline.GetKnotVector().back(), curve_value));
    EXPECT_THAT(eigenmath::SO3d(curve_value),
                IsApprox(eigenmath::SO3d(extra_points[extra_point_count - 1]),
                         kEpsilon));
  }
}

Eigen::AngleAxis<double> GetAngleAxisDiff(const Quaterniond& quat_a,
                                          const Quaterniond& quat_b) {
  Eigen::AngleAxis<double> angle_axis_diff(quat_a.inverse() * quat_b);

  // Wrap angle in [-pi, pi] interval.
  angle_axis_diff.angle() = eigenmath::WrapAngle(angle_axis_diff.angle());

  // Enforce positive angle.
  if (angle_axis_diff.angle() < 0) {
    angle_axis_diff.angle() *= -1;
    angle_axis_diff.axis() *= -1;
  }

  return angle_axis_diff;
}

class BSplineQTest
    : public ::testing::TestWithParam<std::tuple<Quaterniond, Quaterniond>> {};

TEST_P(BSplineQTest, SlerpInterpolationForAABBCase) {
  constexpr size_t kDegree = 3;
  const Quaterniond quat_a = std::get<0>(GetParam());
  const Quaterniond quat_b = std::get<1>(GetParam());

  const std::vector<Quaterniond> points = {quat_a, quat_a, quat_b, quat_b};

  std::vector<double> knots;
  knots.reserve(100);  // reserve plenty
  EXPECT_OK(BSplineBase::MakeUniformKnotVector(points.size(), &knots, kDegree));

  BSplineQ spline;
  ASSERT_OK(spline.Init(kDegree, knots.size()));

  ASSERT_OK(spline.SetKnotVector(knots));
  ASSERT_OK(spline.SetControlPoints(points));

  // Calculate axis/angle offset between first and last point.
  Eigen::AngleAxis<double> angle_axis_diff_overall =
      GetAngleAxisDiff(points[0], points[2]);
  Eigen::Vector3d rotation_axis_overall = angle_axis_diff_overall.axis();
  double rotation_angle_overall = angle_axis_diff_overall.angle();
  double ds = 0.1;
  double previous_rotation_angle = 0.0;
  // Given the first and last point being repeated, the spline should generate
  // slerp interpolation between the first and the last point.
  for (double s = ds; s <= 1.0; s += ds) {
    Quaterniond quat = Quaterniond::Identity();
    ASSERT_OK(spline.EvalCurve(s, quat));

    Eigen::AngleAxis<double> angle_axis_diff =
        GetAngleAxisDiff(points[0], quat);

    // Assert rotation angle monotonically increases.
    ASSERT_GE(angle_axis_diff.angle(), previous_rotation_angle);

    // Assert rotation axis remains equal.
    ASSERT_TRUE(angle_axis_diff.axis().isApprox(rotation_axis_overall));

    previous_rotation_angle = angle_axis_diff.angle();
  }

  ASSERT_NEAR(previous_rotation_angle, rotation_angle_overall, kEpsilon);
}

const eigenmath::SO3d so3_a(0.1, 0.2, 0.3);
const eigenmath::SO3d so3_b(0.4, 0.5, 0.6);

INSTANTIATE_TEST_SUITE_P(
    SlerpInterpolationForAABBCase, BSplineQTest,
    testing::Values(std::make_tuple(Quaterniond(so3_a.quaternion()),
                                    Quaterniond(so3_b.quaternion())),
                    std::make_tuple(Quaterniond(.007, -.707, .707, .007),
                                    Quaterniond(.007, .707, -.707, .007)),
                    std::make_tuple(Quaterniond(.707, .707, 0, 0),
                                    Quaterniond(.707, 0, .707, 0)),
                    std::make_tuple(Quaterniond(.707, 0, .707, 0),
                                    Quaterniond(.707, .707, 0, 0)),
                    std::make_tuple(Quaterniond(.707, 0, .707, 0),
                                    Quaterniond(.707, 0, 0, .707))));

}  // namespace
}  // namespace trajectory_planning
